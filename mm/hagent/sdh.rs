use core::{
    default::Default,
    hash::{BuildHasher, BuildHasherDefault, Hash, Hasher},
    num::Wrapping,
    sync::atomic::{AtomicU64, Ordering},
};

use crate::alloc::*;
use crate::iheap::{FnvHasher, IHeap};
use kernel::prelude::*;

pub struct SDH<H: BuildHasher = BuildHasherDefault<FnvHasher>, A: Allocator = Global> {
    w: usize,
    d: usize,
    k: usize,
    counters: Vec<Vec<(u16, u16), A>, A>,
    topk: IHeap<u64, u16, A>,
    hasher: H,
}

impl SDH<BuildHasherDefault<FnvHasher>, Global> {
    pub fn new(w: usize, d: usize, k: usize) -> Self {
        Self::new_in(w, d, k, Global)
    }
}

impl<A: Allocator + Clone> SDH<BuildHasherDefault<FnvHasher>, A> {
    pub fn new_in(w: usize, d: usize, k: usize, alloc: A) -> Self {
        Self::with_hasher_in(w, d, k, BuildHasherDefault::<FnvHasher>::default(), alloc)
    }
}

impl<H: BuildHasher, A: Allocator + Clone> SDH<H, A> {
    pub fn with_hasher_in(w: usize, d: usize, k: usize, hasher: H, alloc: A) -> Self {
        debug_assert!(d + 1 < SEEDS.len());
        let mut counters = Vec::try_with_capacity_in(d, alloc.clone()).unwrap();
        (0..d).for_each(|_| {
            let mut line = Vec::try_with_capacity_in(w, alloc.clone()).unwrap();
            line.try_resize(w, (0, 0)).unwrap();
            counters.try_push(line).unwrap();
        });
        Self {
            hasher,
            w,
            d,
            k,
            counters,
            topk: IHeap::with_capacity_in(k * 2, alloc),
        }
    }

    fn index(&self, key: u64, i: usize) -> usize {
        let mut hasher = self.hasher.build_hasher();
        SEEDS[i].hash(&mut hasher);
        key.hash(&mut hasher);
        hasher.finish() as usize % self.w
    }

    fn fingerprint(&self, key: u64) -> u16 {
        let mut hasher = self.hasher.build_hasher();
        SEEDS.last().unwrap().hash(&mut hasher);
        key.hash(&mut hasher);
        hasher.finish() as _
    }

    pub fn get(&self, key: u64) -> u16 {
        let fp = self.fingerprint(key);
        (0..self.d)
            .filter_map(|i| {
                let j = self.index(key, i);
                let (f, c) = self.counters[i][j];
                (f == fp).then(|| c)
            })
            .max()
            .unwrap_or(0)
    }

    pub fn add(&mut self, key: u64) -> u16 {
        let topk = self.topk.get(&key).copied();
        let fp = self.fingerprint(key);
        let count = (0..self.d)
            .filter_map(|i| {
                let j = self.index(key, i);
                let (f, c) = &mut self.counters[i][j];
                (*f == fp)
                    .then(|| {
                        let min = self.topk.peek().map(|(_, v)| *v).unwrap_or(0);
                        // detected fingerprint collision
                        // we found a slot backing a top-k address
                        // (notice the > here, it should be in the heap but not
                        if topk.is_none() && *c > min {
                            0
                        } else {
                            *c = c.saturating_add(1);
                            *c
                        }
                    })
                    .or_else(||
                        // fingerprint mismtach: should decay
                        // for empty slots, insertion will also falls here
                        (random() % powb(*c) == 0)
                            .then(|| {
                                *c = c.saturating_sub(1);
                                (*c == 0).then(|| {
                                    *f = fp;
                                    *c = 1;
                                    1
                                })
                            })
                            .flatten())
            })
            .max()
            .unwrap_or(0);

        topk.map(|idx| {
            // we have queried in the beginning, it must not be None
            if count > 0 {
                self.topk.update(idx, count);
            } else {
                self.topk.remove(idx);
            }
        })
        .or_else(|| {
            if self.topk.len() < self.k {
                if count > 0 {
                    self.topk.push((key, count));
                }
            } else {
                // full, replace the heap min
                // the length is k, it must not be None
                let (_, v) = self.topk.peek().unwrap();
                // = is included because recency wins
                if *v <= count {
                    self.topk.replace(0, (key, count));
                } else {
                    // discard rarely accessed addresses
                }
            }
            Some(())
        });

        count
    }
}

pub mod ffi {
    use super::SDH;
    use kernel::{pr_cont, prelude::*};

    #[no_mangle]
    pub extern "C" fn sdh_new(w: usize, d: usize, k: usize) -> Box<SDH> {
        Box::try_new(SDH::new(w, d, k)).unwrap()
    }

    #[no_mangle]
    pub extern "C" fn sdh_get(sdh: Option<&SDH>, key: u64) -> u16 {
        sdh.unwrap().get(key)
    }

    #[no_mangle]
    pub extern "C" fn sdh_add(sdh: Option<&mut SDH>, key: u64) -> u16 {
        sdh.unwrap().add(key)
    }

    #[no_mangle]
    pub extern "C" fn sdh_drop(_sdh: Option<Box<SDH>>) {
        // silently drop the boxed value
    }

    #[no_mangle]
    pub extern "C" fn sdh_show_topk(sdh: Option<&SDH>) {
        pr_info!("top-k (address, count):");
        sdh.unwrap()
            .topk
            .data()
            .iter()
            .for_each(|(k, c)| pr_cont!(" (0x{k:x}, {c})"));
    }
}

fn random() -> u64 {
    fn squares64(ctr: u64, key: u64) -> u64 {
        let mut x = Wrapping(ctr) * Wrapping(key);
        let y = x;
        let z = y + Wrapping(key);
        x = x * x + y;
        x = (x >> 32) | (x << 32);
        x = x * x + z;
        x = (x >> 32) | (x << 32);
        x = x * x + y;
        x = (x >> 32) | (x << 32);
        x = x * x + z;
        let t = x;
        x = (x >> 32) | (x << 32);
        (t ^ ((x * x + y) >> 32)).0
    }
    static COUNTER: AtomicU64 = AtomicU64::new(0);
    squares64(COUNTER.fetch_add(1, Ordering::Relaxed), 0xc8e4fd154ce32f6d)
}

fn powb(exp: u16) -> u64 {
    let exp = exp as usize;

    #[rustfmt::skip]
    const POWERS: &[u64] = &[1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,5,5,5,6,6,7,7,8,9,10,10,11,12,13,14,15,17,18,20,21,23,25,27,29,31,34,37,40,43,46,50,54,59,63,68,74,80,86,93,101,109,118,127,137,148,160,173,187,202,218,236,254,275,297,321,346,374,404,436,471,509,550,594,642,693,748,808,873,943,1018,1100,1188,1283,1386,1497,1616,1746,1885,2036,2199,2375,2565,2771,2992,3232,3490,3770,4071,4397,4749,5129,5539,5982,6461,6978,7536,8139,8790,9493,10252,11073,11959,12915,13949,15065,16270,17571,18977,20495,22135,23906,25818,27884,30115,32524,35126,37936,40971,44248,47788,51611,55740,60200,65016,70217,75834,81901,88453,95529,103172,111426,120340,129967,140364,151594,163721,176819,190964,206242,222741,240560,259805,280589,303037,327280,353462,381739,412278,445261,480881,519352,560900,605772,654234,706573,763099,824147,890078,961285,1038187,1121242,1210942,1307817,1412443,1525438,1647473,1779271,1921613,2075342,2241369,2420679,2614333,2823480,3049359,3293307,3556772,3841314,4148619,4480508,4838949,5226065,5644150,6095682,6583337,7110004,7678804,8293109,8956557,9673082,10446929,11282683,12185298,13160122,14212931,15349966,16577963,17904200,19336536,20883459,22554136,24358467,26307144,28411716,30684653,33139426,35790580,38653826,41746132,45085823,48692689,52588104,56795152,61338765,66245866,71545535,77269178,83450712,90126769,97336911,105123864,113533773,122616475,132425793,143019856,154461445,166818360,180163829,194576936,210143091,226954538,245110901,264719773,285897355,308769143,333470675,360148329,388960195,420077011,453683172,489977826,529176052,571510136,617230947,666609423,719938177,777533231,839735889,906914760,979467941,1057825377,1142451407,1233847519,1332555321,1439159747,1554292526,1678635929,1812926803,1957960947,2114597823,2283765649,2466466901,2663784253,2876886993,3107037953,3355600989,3624049068,3913972994,4227090833,4565258100,4930478748,5324917048,5750910412,6210983244,6707861904,7244490856,7824050125,8449974135,9125972066,9856049831,10644533818,11496096523,12415784245,13409046985,14481770744,15640312403,16891537395,18242860387,19702289218,21278472356,22980750144,24819210156,26804746968,28949126726,31265056864,33766261413,36467562326,39384967312,42535764697,45938625873,49613715943,53582813218,57869438276,62498993338,67498912805,72898825829,78730731895,85029190447,91831525683,99178047738,107112291557,115681274881,124935776872,134930639022,145725090143,157383097355,169973745143,183571644755,198257376335,214117966442,231247403758,249747196058,269726971743,291305129482,314609539841,339778303028,366960567271,396317412652,428022805665,462264630118,499245800527,539185464569,582320301735,628905925874,679218399944,733555871939,792240341694,855619569030,924069134553,997994665317,1077834238542,1164060977626,1257185855836,1357760724303,1466381582247,1583692108827,1710387477533,1847218475735,1994995953794,2154595630098,2326963280506,2513120342946,2714169970382,2931303568012,3165807853454,3419072481730,3692598280268,3988006142690,4307046634105,4651610364833,5023739194020,5425638329542,5859689395905,6328464547578,6834741711384,7381521048295,7972042732158,8609806150731,9298590642789,10042477894213,10845876125750,11713546215810,12650629913075,13662680306121,14755694730610,15936150309059,17211042333784,18587925720487,20074959778126,21680956560376,23415433085206,25288667732022,27311761150584,29496702042631,31856438206042,34404953262525,37157349523527,40129937485409,43340332484242,46807559082981,50552163809620,54596336914389,58964043867541,63681167376944,68775660767099,74277713628467,80219930718745,86637525176245,93568527190344,101054009365572,109138330114818,117869396524003,127298948245923,137482864105597,148481493234045,160360012692769,173188813708190,187043918804845,202007432309233,218168026893972,235621469045490,254471186569129,274828881494659,296815192014232,320560407375371,346205239965400,373901659162633,403813791895643,436118895247295,471008406867078,508689079416445,549384205769760,593334942231341,640801737609849,692065876618637,747431146748128,807225638487978,871803689567016,941547984732378,1016871823510968,1098221569391845,1186079294943193,1280965638538649,1383442889621741,1494118320791480,1613647786454799,1742739609371183,1882158778120877,2032731480370548,2195349998800192,2370977998704207,2560656238600544,2765508737688588,2986749436703675,3225689391639969,3483744542971166,3762444106408860,4063439634921569,4388514805715295,4739595990172519,5118763669386321,5528264762937227,5970525943972206,6448168019489983,6964021461049182,7521143177933117,8122834632167767,8772661402741189,9474474314960484,10232432260157324,11051026840969910,11935108988247504,12889917707307306,13921111123891892,15034800013803244,16237584014907504,17536590736100106,18939517994988116,20454679434587170,22091053789354144,23858338092502476,25767005139902676,27828365551094892,30054634795182484,32459005578797084,35055726025100852,37860184107108920,40888998835677640,44160118742531860,47692928241934410,51508362501289170,55629031501392300,60079354021503700,64885702343223990,70076558530681910,75682683213136460,81737297870187400,88276281699802380,95338384235786580,102965454974649500,111202691372621470,120098906682431200,129706819217025710,140083364754387780,151290033934738800,163393236649517920,176464695581479360,190581871227997730,205828420926237570,222294694600336580,240078270168363520,259284531781832600,280027294324379230,302429477870329600,326623836099956000,352753742987952450,380974042426988700,411451965821147800,444368123086839600,479917572933786800,518310978768489800,559775857069969000,604557925635566600,652922559686411900,705156364461324900,761568873618230900,822494383507689500,888293934188304600,959357448923369100,1036106044837238700,1118994528424217900,1208514090698155300,1305195217954007800,1409610835390328600,1522379702221555000,1644170078399279400,1775703684671221800,1917759979444919600,2071180777800513300,2236875240024554500,2415825259226519000,2609091279964641000,2817818582361812000,3043244068950757400,3286703594466818000,3549639882024164000,3833611072586097000,4140299958392985000,4471523955064424000,4829245871469578000,5215585541187145000,5632832384482117000,6083458975240687000,6570135693259942000,7095746548720737000,7663406272618397000,8276478774427869000,8938597076382099000,9653684842492668000,10425979629892082000,11260058000283450000,12160862640306127000,13133731651530619000,14184430183653069000,15319184598345314000,16544719366212940000,17868296915509977000];

    (exp < POWERS.len())
        .then(|| POWERS[exp])
        .or_else(|| POWERS.last().copied())
        .unwrap()
}

const SEEDS: &[u64] = &[
    0x33196aa8cc858657,
    0x6179cbf6b196383b,
    0xa1610262ded8fa0b,
    0xd8c952cb2ef31ba9,
    0xe114c80821dc3c2d,
    0xa84c339b589fba0d,
    0x5fad4f73926745a7,
    0x4ab127efa48fb499,
    0x766edfff707a4be7,
    0xd50e23f52f5ca7a9,
    0x4958c180e1b0b4cd,
    0x596dd0e6afa981d1,
    0x5fb76b53d26960fd,
    0x926593c357ed5b57,
    0xb82d62310fdca4b5,
    0xa8dffd9f432c0941,
    0x183ac9a532e05,
    0xc9360c116079424d,
    0x96af9ff5b0d48419,
    0x9b73fd5c6b166797,
    0x41da1caf8189081f,
    0x3db6cc2ab5dd26f,
    0xdb576c830463e579,
    0x614028bdc177e407,
    0xb4fe2dd598d7fd1,
    0x1fba31ef9b3c2fe3,
    0xa9508a700af534c9,
    0x8fa0e730fb408885,
    0x153cdbe1464d8ff3,
    0x52df1d0c030b94ab,
    0x90466ff586985b87,
    0x92d6a332fad149f7,
    0x8f7fbcc8696b378b,
];
